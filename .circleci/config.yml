version: 2.1

# export PLAN_ARGS
# terraform destroy -input=false -no-color -auto-approve $PLAN_ARGS "$module_path"

aliases:
  params:
    path: &path
      type: "string"
      description: "Path to the terraform module"
    secrets: &secrets
      context: cdk8s
    lifecycle_seq: &lifecycle_seq
      - init
      - fmt
      - validate
      - plan
      - apply
      - destroy

# codify structure of orb inline
orbs:
  # orb name @ top
  tf:
    # the 'tf' orb contains the following jobs
    jobs:
      # pass a map of jobs
      init: # init terraform directory
        executor: terraform-executor
        working_directory: "~/src"
        steps:
          - checkout
          - t:
            # nest the param(s) under the command declaration
              cmd_name: "init"
      # going to codify the rest of the "dummy" job declarations
      validate:
        executor: terraform-executor
        working_directory: "/src"
        steps:
          - checkout
          - t:
              cmd_name: "validate"
      plan:
        executor: terraform-executor
        working_directory: "/src"
        steps:
          - checkout
      apply:
        description: "Apply a Terraform plan"
        executor: terraform-executor
        working_directory: "/src"
        steps:
          - checkout
      destroy:
        executor: terraform-executor
        working_directory: "/src"
        steps:
          - checkout
          - destroy
      test-command-sequence:
        description: perform e2e tests on command sequence
        executor: terraform-executor
        working_directory: "/src"
        steps:
          - checkout
          # execute terraform lifecycle
          - init
          - fmt
          - validate
          - plan
          - apply
          - destroy
    commands:
      # t is a generalized abstraction
      t:
        parameters:
          cmd_name:
            type: string
            default: ""
        steps:
          - run:
              name: terraform << parameters.cmd_name >>
              command: terraform << parameters.cmd_name >>
      # all of the top level commands included in the atomic
      # job declarations will be made available as individual commands
      init:
        parameters:
          ## param map goes here
          options:
            type: string
            default: ""
        steps:
          - run:
              name: terraform init
              command: terraform init
      validate:
        steps:
          - run:
              name: terraform validate
              command: terraform validate
      fmt:
        steps:
          - run:
              name: terraform fmt
              command: terraform fmt
      plan:
        steps:
          - run:
            # need to parameterize input and output
              name: terraform plan
              command: terraform plan
      apply:
        steps:
          - run:
              name: terraform apply
              command: terraform apply -auto-approve
      destroy:
        steps:
          - run:
              name: terraform destroy
              command:  terraform destroy -input=false -no-color -auto-approve
    executors:
      terraform-executor:
        parameters:
          working_dir:
            type: string
            default: "~/src"
        # specify executor type ~ any reason to make resource class a param?
        docker:
          - image: hashicorp/terraform:light
        working_directory: << parameters.working_dir >>

workflows:
  plan-approve-apply:
    jobs:
      #- tf/destroy:
      #    <<: *secrets
      - tf/test-command-sequence:
          <<: *secrets
      
        